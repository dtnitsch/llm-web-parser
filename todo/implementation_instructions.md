# Technical Specification: File-Based Artifact Management (Cache)

## Objective

To implement a robust, transparent, and user-friendly file-based system for storing and retrieving web artifacts (raw HTML, parsed JSON) generated by `llm-web-parser`. This system will serve as a persistent cache, enabling multi-stage workflows without redundant network fetches.

## Core Design Principles

1.  **Local-First & Portable:** Artifacts will be stored in a subdirectory within the current working directory, making project results self-contained and portable.
2.  **Structured Storage:** Dedicated subdirectories will separate raw, parsed, and other artifact types for clarity and queryability.
3.  **Hybrid Filenaming:** Filenames will combine human-readability with robust, deterministic uniqueness to prevent collisions and ensure consistent lookup, even for URLs with varied query parameters.
4.  **Transparent Operation:** From the user's perspective, the tool manages its own result files. "Caching" is an internal optimization to avoid re-doing work.
5.  **Deterministic & Auditable:** All operations (URL normalization, hashing, path generation) must be 100% deterministic and the resulting files inspectable.

## Key Components & Implementation Details

### 1. **`pkg/artifact_manager` Package**

*   **Purpose:** This new package will encapsulate all logic for creating, storing, retrieving, and managing artifacts on the filesystem.
*   **`Manager` Struct:**
    *   Fields: `baseDir` (string, the root directory for artifacts, e.g., `./llm-web-parser-results`), `maxAge` (time.Duration, the maximum age for an artifact to be considered fresh).
    *   `NewManager(baseDir string, maxAge time.Duration)` constructor:
        *   If `baseDir` is empty, default to `"llm-web-parser-results"`.
        *   Ensure the base directory exists.
        *   Ensure critical subdirectories (`raw`, `parsed`) exist within `baseDir`.
*   **Constants:**
    *   `DefaultBaseDir = "llm-web-parser-results"`
    *   `RawHTMLDir = "raw"` (for storing raw HTML content)
    *   `ParsedJSONDir = "parsed"` (for storing parsed `models.Page` JSON output)

### 2. **URL Normalization (Crucial for Hashing Consistency)**

*   **`normalizeURL(rawURL string)` function:** This function will convert any given URL into a consistent, canonical string representation. This normalized string is what will be hashed to ensure that logically identical URLs (e.g., with reordered query parameters) produce the same filename.
    *   Parse the `rawURL` using `net/url.Parse`.
    *   Always use `https` if the scheme is `http`.
    *   Convert the hostname to lowercase.
    *   **Crucially, sort all query parameters alphabetically by key.**
    *   Remove URL fragments (e.g., `#section`).
    *   Return the reconstructed, normalized URL string.

### 3. **Filename Generation (Hybrid Approach)**

*   **`getShortHash(normalizedURL string)` function:**
    *   Take the output of `normalizeURL`.
    *   Compute a SHA256 hash of this normalized URL.
    *   Return a short, fixed-length hexadecimal string (e.g., the first 12 characters of the hash) to serve as a robust unique identifier.
*   **`sanitizeSlug(rawURL string)` function:**
    *   Generate a human-readable, filesystem-safe slug from the original (non-normalized) URL.
    *   Replace invalid filename characters with underscores.
    *   Combine hostname and path segments, e.g., `www_example_com_docs_api`.
*   **`getArtifactPath(artifactDir, url string, ext string)` method (within `Manager`):**
    *   This method will combine the `baseDir`, `artifactDir` (`raw` or `parsed`), the `sanitizeSlug` output, the `getShortHash` output, and the file extension (`.html` or `.json`) to construct the final artifact path.
    *   Example: `./llm-web-parser-results/raw/www_example_com_docs-a3f1c9.html`

### 4. **Artifact Storage & Retrieval Methods (Within `Manager`)**

*   **`GetRawHTML(url string)` method:**
    *   Construct the artifact path using `getArtifactPath` (for `RawHTMLDir`, `.html` extension).
    *   Check `os.Stat(filePath)`:
        *   If `os.IsNotExist(err)`: Return "not found".
        *   If `err` (other error): Return error.
    *   Check freshness: If `Manager.maxAge > 0` and `time.Since(fileInfo.ModTime()) > Manager.maxAge`: Return "stale".
    *   Read `os.ReadFile(filePath)`: Return content and "fresh".
*   **`SetRawHTML(url string, data []byte)` method:**
    *   Construct the artifact path using `getArtifactPath`.
    *   Write `data` to `filePath` using `os.WriteFile`.
*   **`GetParsedJSON(url string)` method:** (Similar logic to `GetRawHTML`, but for `ParsedJSONDir`, `.json` extension).
*   **`SetParsedJSON(url string, data []byte)` method:** (Similar logic to `SetRawHTML`, but for `ParsedJSONDir`, `.json` extension).

### 5. **Integration into `main.go`**

*   **`fetchAction` Function (CLI Flags & Manager Initialization):**
    *   Add `--output-dir` flag (default: `DefaultBaseDir`).
    *   Rename `--cache-ttl` to `--max-age`.
    *   Add `--force-fetch` (boolean) flag for explicit cache busting.
    *   Initialize the `Manager` using these flags.
*   **`run` Function (Orchestration):**
    *   Accept the `*Manager` instance.
    *   Pass the `*Manager` instance to each `worker` goroutine.
*   **`worker` Function (Fetch Logic):**
    *   Before fetching `rawHTML`:
        *   If `forceFetch` is true, skip artifact manager lookup.
        *   Call `Manager.GetRawHTML(job.URL)`.
        *   If fresh, use stored `rawHTML`.
    *   If fetched from network:
        *   Call `Manager.SetRawHTML(job.URL, rawHTML)`.
    *   After parsing HTML to `models.Page` and marshaling to JSON:
        *   Call `Manager.SetParsedJSON(job.URL, jsonData)`.
        *   **Crucially, update the `Result.FilePath` to point to the new, managed artifact path (e.g., in `./llm-web-parser-results/parsed/`).** (This replaces the old `getSavePath` logic for final output reporting).

### 6. **Update `pkg/fetcher/fetcher.go`**

*   Modify `GetHtml(url string)` to internally call `GetHtmlBytes` and then parse the bytes into a `goquery.Document`. This keeps `GetHtmlBytes` as the canonical fetch method for raw HTML.

## Next Steps for the Implementer (Flash Model or You)

1.  **Create `pkg/artifact_manager/manager.go`** with the content described above.
2.  **Update `pkg/fetcher/fetcher.go`** with the new `GetHtmlBytes` function and modify `GetHtml` to use it.
3.  **Modify `main.go`** to integrate the `artifact_manager`, flags, and updated `run`/`worker` logic. This will be the most involved step, requiring careful replacement of flag definitions, initialization logic, function signatures, and worker/processHTML bodies.

Each of these steps should be performed and verified independently.

This document should provide all the necessary detail to implement the artifact management system.
